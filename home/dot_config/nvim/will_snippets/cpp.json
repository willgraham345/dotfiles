{
	"for": {
		"prefix": "for",
		"body": [
			"for (${size_t} ${i} = ${1:0}; ${i} < ${2:length}; ${i}++)",
			"{",
			"	$3",
			"}"
		],
		"description": "Code snippet for 'for' loop"
	},
	"forr": {
		"prefix": "forr",
		"body": [
			"for (int ${i} = ${1:length} - 1; ${i} >= ${2:0}; ${i}--)",
			"{",
			"	$3",
			"}"
		],
		"description": "Code snippet for reverse 'for' loop"
	},
	"do": {
		"prefix": "do",
		"body": [
			"do",
			"{",
			"	$1",
			"} while($2);"
		],
		"description": "Code snippet for do...while loop"
	},
	"while": {
		"prefix": "while",
		"body": [
			"while ($1)",
			"{",
			"	$2",
			"}"
		],
		"description": "Code snippet for while loop"
	},
	"foreach": {
		"prefix": "foreach",
		"body": [
			"for(auto ${var} : ${collection_to_loop})",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for range-based for loop (c++11) statement"
	},
	"if": {
		"prefix": "if",
		"body": [
			"if ($1)",
			"{",
			"	$2",
			"}"
		],
		"description": "Code snippet for if statement"
	},
	"else": {
		"prefix": "else",
		"body": [
			"else",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for else statement"
	},
	"else if": {
		"prefix": "else if",
		"body": [
			"else if ($1)",
			"{",
			"	$2",
			"}"
		],
		"description": "Code snippet for else-if statement"
	},
	"enum": {
		"prefix": "enum",
		"body": [
			"enum ${MyEnum}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for enum"
	},
	"enum class": {
		"prefix": "enum class",
		"body": [
			"enum class ${MyClass} { };"
		],
		"description": "Code snippet for enum class (c++11)"
	},
	"class": {
		"prefix": "class",
		"body": [
			"class ${MyClass}",
			"{",
			"public:",
			"	${MyClass}();",
			"	${MyClass}(${MyClass} &&) = default;",
			"	${MyClass}(const ${MyClass} &) = default;",
			"	${MyClass} &operator=(${MyClass} &&) = default;",
			"	${MyClass} &operator=(const ${MyClass} &) = default;",
			"	~${MyClass}();",
			"",
			"private:",
			"	$1",
			"};",
			"",
			"${MyClass}::${MyClass}()",
			"{",
			"}",
			"",
			"${MyClass}::~${MyClass}()",
			"{",
			"}"
		],
		"description": "Code snippet for class"
	},
	"classi": {
		"prefix": "classi",
		"body": [
			"class ${MyClass}",
			"{",
			"public:",
			"	${MyClass}() = default;",
			"	${MyClass}(${MyClass} &&) = default;",
			"	${MyClass}(const ${MyClass} &) = default;",
			"	${MyClass} &operator=(${MyClass} &&) = default;",
			"	${MyClass} &operator=(const ${MyClass} &) = default;",
			"	~${MyClass}() = default;",
			"",
			"private:",
			"	$1",
			"};"
		],
		"description": "Code snippet for class with inline constructor/destructor"
	},
	"interface": {
		"prefix": "interface",
		"body": [
			"__interface I${Interface}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for interface (Visual C++)"
	},
	"namespace": {
		"prefix": "namespace",
		"body": [
			"namespace ${MyNamespace}",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for namespace"
	},
	"#ifdef": {
		"prefix": "#ifdef",
		"body": [
			"#ifdef ${DEBUG}",
			"$1",
			"#endif // ${DEBUG}"
		],
		"description": "Code snippet for #ifdef"
	},
	"#ifndef": {
		"prefix": "#ifndef",
		"body": [
			"#ifndef ${1:1}",
			"$2",
			"#endif // !$1"
		],
		"description": "Code snippet for #ifndef"
	},
	"#if": {
		"prefix": "#if",
		"body": [
			"#ifdef ${1:0}",
			"$2",
			"#endif // $1"
		],
		"description": "Code snippet for #if"
	},
	"struct": {
		"prefix": "struct",
		"body": [
			"struct ${MyStruct}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for struct"
	},
	"switch": {
		"prefix": "switch",
		"body": [
			"switch (${switch_on})",
			"{",
			"default:",
			"	break;$1",
			"}"
		],
		"description": "Code snippet for switch statement"
	},
	"try": {
		"prefix": "try",
		"body": [
			"try",
			"{",
			"	",
			"}",
			"catch (const std::exception&)",
			"{",
			"	$1",
			"}"
		],
		"description": "Code snippet for try catch"
	},
	"union": {
		"prefix": "union",
		"body": [
			"union ${MyUnion}",
			"{",
			"	$1",
			"};"
		],
		"description": "Code snippet for union"
	},
	"cout": {
		"prefix": "cout",
		"body": [
			"std::cout << \"${1:/* message */}\" << std::endl;"
		],
		"description": "Code snippet for printing to std::cout, provided the header is set"
	},
	"#inc": {
		"prefix": "#inc",
		"body": [
			"#include \"$1\""
		],
		"description": "Code snippet for #include \" \""
	},
	"#inc<": {
		"prefix": "#inc<",
		"body": [
			"#include <$1>"
		],
		"description": "Code snippet for #include \" \""
	},
	"#def": {
		"prefix": "#def",
		"body": [
			"#define \"$1\" \"$2\" "
			],
		"description": "Code snippet for #define \" \""
	},
	"main": {
		"prefix": "main",
		"body": [
			"int main(int argc, const char** argv) {",
			"    return 0;",
			"}"
		],
		"description": "Code snippet for main function"
	},
	"xteds_base_app": {
		"prefix": "xteds base app",
		"body": [
			"//HEADER",
			"class ${1: AppName} : public SpaApplication",
			"{",
			"\tpublic:",
			"\t\t${1: AppName}();",
			"\t\tvoid appInit(Int32 argc, char** pArgv);",
			"\t\tvoid appShutdown(void);",
			"\tprivate:",
			"\t\tCALLBACK_CONFIG(${1: AppName});",
			"//SOURCE"
			"${1: AppName} :: ${1: AppName}()",
			"\t: SpaAppliction(\"${1: AppName}\"),"
			"{",
			"",
			"}",
			"void ${1: AppName}::appInit(Int32 argc, char** pArgv)",
			"{",
			"",
			"}",
		],
		"description": "Base for defining SpaApplication hpp/cpp"
	},
	"xteds_notification_query": {
		"prefix": "xteds_notification_query",
		"body": [
			"//HEADER",
			"public:",
			"\t//callbacks",
			"\tvoid on${1:dataName}Received(SpaMessage*);",
			"private:",
			"\t//Message handles",
			"\tNotificationMsg m_queried${2:notifName};"
			"",
			"\t//variables",
			"\t${3:DataType} m_recv${1:dataName};",
			"\t"
			"//SOURCE",
			"//in constructor",
			"m_queried${2:notifName},",
			"m_recv${1:dataName}",
			"//in appInit",
			"\tm_queried${2:notifName}.addVariable(VariableType(${4:DataTypeType}), &m_recv${1:dataName});",
			"\tm_queried${2:notifName}.onDataReceived = callback(&${5:AppName}::on${1:dataName}Received);",
			"issueQuery(myQuery, &m_queried${2:notifName});",
			"}",
			"//in source file as its own method",
			"void ${5:AppName}::on${1:dataName}Recived(SpaMessage* pMsg)",
			"{",
			"\t//data now exists to be handled",
			"}"
		],
		"description": "Format for handling notifications that are queried"
	},
	"xteds_notification_provide": {
		"prefix": "xteds_notification_provide",
		"body": [
			"//HEADER",
			"public:",
			"\t//callbacks",
			"\tvoid my${1:dataName}Publish(void);",
			"private:",
			"\t//Message handles",
			"\tNotificationMsg m_queried${2:notifName};"
			"",
			"\t//variables",
			"\t${3:DataType} m_my${1:dataName};",
			"\t"
			"//SOURCE",
			"//in constructor",
			"m_queried${2:notifName}(${4:interfaceId} ${5:messageId}),",
			"//in appInit",
			"\tm_queried${2:notifName}.addVariable(VariableType(${6:DataTypeType}), &m_my${1:dataName});",
			"\tm_queried${2:notifName}.onDataReceived = callback(&${7:AppName}::my${1:dataName}Publish);",
			"issueQuery(myQuery, &m_queried${2:notifName});",
			"}",
			"//in source file as its own method",
			"void ${7:AppName}::my${1:dataName}Publish(void)",
			"{",
			"\t//make sure ${1:dataName}is up to date and ready to be published",
			"}"
		],
		"description": "Handles notifications that are provided by the app, not queried by the app"
	},
	"xteds_command": {
		"prefix": "xteds_command",
		"body": [
			"//HEADER",
			"public:",
			"\t//callbacks",
			"\tvoid on${1:cmdName}(void);",
			"private:",
			"\t//Message handles",
			"\tCommandMsg m_my${1:cmdName};"
			"",
			"\t//variables",
			"\t${2:DataType} m_recv${1:cmdName};",
			"\t"
			"//SOURCE",
			"//in constructor",
			"m_my${1:cmdName}(${3:interfaceId}, ${4:messageId}),",
			"//in appInit",
			"m_my${1:cmdName}.onCommandReceived = callback(&${5:AppName}::on${1:cmdName});"
			"}",
			"//in source file as its own method",
			"void ${5:AppName}::on${1:cmdName}(void)",
			"{",
			"\t//handle receipt of the command here",
			"}"
		],
		"description": "Format for handling notifications that are queried"
	},
	"gtest": {
		"prefix": "gtest test fixture",
		"body": [
			"TEST_F(${1:testFixture}, ${2:testName})",
			"{",
			"\t${0}"
			"}"
		],
		"description": "Creates a google test fixture"
	}
}